/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, visit the github repository
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FigmaObsidianSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  figmaToken: "",
  syncFolder: "Figma Comments",
  syncInterval: 3e5,
  // 5 minutes in milliseconds
  figmaFiles: [],
  tokenVisible: false,
  fetchFrameInfo: false,
  deleteToTrash: true
};
var DEFAULT_RUNTIME_DATA = {
  lastSync: "",
  frameInfoCache: {}
};
var TokenManager = class {
  static encrypt(text) {
    if (!text)
      return "";
    let encrypted = "";
    for (let i = 0; i < text.length; i++) {
      const charCode = text.charCodeAt(i) ^ this.SECRET_KEY.charCodeAt(i % this.SECRET_KEY.length);
      encrypted += String.fromCharCode(charCode);
    }
    return btoa(encrypted);
  }
  static decrypt(encrypted) {
    if (!encrypted)
      return "";
    try {
      const text = atob(encrypted);
      let decrypted = "";
      for (let i = 0; i < text.length; i++) {
        const charCode = text.charCodeAt(i) ^ this.SECRET_KEY.charCodeAt(i % this.SECRET_KEY.length);
        decrypted += String.fromCharCode(charCode);
      }
      return decrypted;
    } catch (e) {
      return "";
    }
  }
  static validateToken(token) {
    return token.length > 0 && (token.startsWith("figd_") || token.length >= 40);
  }
};
TokenManager.SECRET_KEY = "figma-obsidian-sync-2025";
var FolderMigrationManager = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async migrateSyncFolder(oldPath, newPath) {
    if (oldPath === newPath)
      return true;
    const existingFiles = await this.detectExistingFiles(oldPath);
    if (existingFiles.length === 0)
      return true;
    const confirmed = await this.showMigrationDialog(existingFiles, newPath);
    if (!confirmed)
      return false;
    try {
      await this.moveFiles(oldPath, newPath);
      new import_obsidian.Notice(`Successfully migrated ${existingFiles.length} files to ${newPath}`);
      return true;
    } catch (error) {
      new import_obsidian.Notice(`Migration failed: ${error.message}`);
      return false;
    }
  }
  async detectExistingFiles(path) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (!folder || !(folder instanceof import_obsidian.TFolder))
      return [];
    const files = [];
    const traverse = (folder2) => {
      folder2.children.forEach((child) => {
        if (child instanceof import_obsidian.TFile && child.path.endsWith("_comments.md")) {
          files.push(child.path);
        } else if (child instanceof import_obsidian.TFolder) {
          traverse(child);
        }
      });
    };
    traverse(folder);
    return files;
  }
  async showMigrationDialog(files, newPath) {
    return new Promise((resolve) => {
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.textContent = "Sync folder migration";
      const content = modal.contentEl;
      content.createEl("p", { text: `Found ${files.length} existing sync files. Do you want to move them to the new location?` });
      const fileList = content.createEl("ul");
      files.forEach((file) => {
        fileList.createEl("li", { text: file });
      });
      content.createEl("p", { text: `New location: ${newPath}` });
      const buttonContainer = content.createEl("div", { cls: "modal-button-container" });
      new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
        modal.close();
        resolve(false);
      });
      new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Move files").setCta().onClick(() => {
        modal.close();
        resolve(true);
      });
      modal.open();
    });
  }
  async moveFiles(oldPath, newPath) {
    const files = await this.detectExistingFiles(oldPath);
    await this.ensureFolder(newPath);
    for (const filePath of files) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        const fileName = file.name;
        const newFilePath = (0, import_obsidian.normalizePath)(`${newPath}/${fileName}`);
        await this.app.vault.rename(file, newFilePath);
      }
    }
    try {
      const oldFolder = this.app.vault.getAbstractFileByPath(oldPath);
      if (oldFolder instanceof import_obsidian.TFolder && oldFolder.children.length === 0) {
        if (this.plugin.settings.deleteToTrash) {
          await this.app.fileManager.trashFile(oldFolder);
        } else {
          await this.app.vault.delete(oldFolder);
        }
      }
    } catch (e) {
    }
  }
  async ensureFolder(path) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.app.vault.createFolder(path);
    }
  }
};
var FrameInfoFetcher = class {
  constructor(token, cache) {
    this.token = token;
    this.cache = cache;
  }
  async getFrameInfo(fileKey, nodeId, coordinates) {
    if (nodeId && nodeId !== "0:1") {
      return await this.getFrameInfoByNodeId(fileKey, nodeId);
    }
    if (coordinates && coordinates.x !== void 0 && coordinates.y !== void 0) {
      return await this.getFrameInfoByCoordinates(fileKey, coordinates.x, coordinates.y);
    }
    return null;
  }
  async getFrameInfoByNodeId(fileKey, nodeId) {
    const cachedInfo = this.getCachedFrameInfo(fileKey, nodeId);
    if (cachedInfo) {
      return cachedInfo;
    }
    const fileStructure = await this.fetchFileStructure(fileKey);
    if (!fileStructure) {
      return null;
    }
    const frameInfo = this.findFrameInfo(nodeId, fileStructure);
    if (frameInfo) {
      this.cacheFrameInfo(fileKey, nodeId, frameInfo);
    }
    return frameInfo;
  }
  async getFrameInfoByCoordinates(fileKey, x, y) {
    const coordKey = `coord_${x}_${y}`;
    const cachedInfo = this.getCachedFrameInfo(fileKey, coordKey);
    if (cachedInfo) {
      return cachedInfo;
    }
    const fileStructure = await this.fetchFileStructure(fileKey);
    if (!fileStructure) {
      return null;
    }
    const frameInfo = this.findFrameAtCoordinates(x, y, fileStructure);
    if (frameInfo) {
      this.cacheFrameInfo(fileKey, coordKey, frameInfo);
    }
    return frameInfo;
  }
  getCachedFrameInfo(fileKey, nodeId) {
    const cache = this.cache[fileKey];
    if (!cache)
      return null;
    const cacheAge = Date.now() - new Date(cache.lastUpdated).getTime();
    if (cacheAge > 24 * 60 * 60 * 1e3) {
      delete this.cache[fileKey];
      return null;
    }
    return cache.frameMap[nodeId] || null;
  }
  async fetchFileStructure(fileKey) {
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `https://api.figma.com/v1/files/${fileKey}?depth=3&geometry=paths`,
        method: "GET",
        headers: {
          "X-Figma-Token": this.token
        }
      });
      if (response.status !== 200) {
        console.error("Failed to fetch file structure:", response.status);
        return null;
      }
      const data = response.json;
      if (!this.cache[fileKey]) {
        this.cache[fileKey] = {
          fileKey,
          lastUpdated: new Date().toISOString(),
          frameMap: {},
          fileStructure: data
        };
      }
      return data;
    } catch (error) {
      console.error("Error fetching file structure:", error);
      return null;
    }
  }
  findFrameAtCoordinates(x, y, fileData) {
    let bestMatchNode = null;
    let bestMatchPath = [];
    let bestScore = -1;
    this.traverseNodes(fileData.document, (node, path) => {
      if (this.isFrameNode(node) && node.absoluteBoundingBox) {
        const bounds = node.absoluteBoundingBox;
        if (this.isPointInBounds(x, y, bounds)) {
          const area = bounds.width * bounds.height;
          const score = 1e6 / area;
          if (score > bestScore) {
            bestScore = score;
            bestMatchNode = node;
            bestMatchPath = path;
          }
        }
      }
    });
    if (bestMatchNode) {
      return this.buildFrameInfoFromPath(bestMatchNode, bestMatchPath);
    }
    return null;
  }
  isFrameNode(node) {
    return node.type === "FRAME" || node.type === "COMPONENT" || node.type === "INSTANCE";
  }
  isPointInBounds(x, y, bounds) {
    return x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;
  }
  traverseNodes(node, callback, path = []) {
    const currentPath = [...path, node];
    callback(node, currentPath);
    if (node.children) {
      for (const child of node.children) {
        this.traverseNodes(child, callback, currentPath);
      }
    }
  }
  buildFrameInfoFromPath(node, path) {
    const page = path.find((n) => n.type === "CANVAS");
    const pageName = page ? page.name : "Unknown Page";
    const pageIndex = path.findIndex((n) => n.type === "CANVAS");
    const framePathNodes = path.slice(pageIndex + 1);
    const fullPath = framePathNodes.map((n) => n.name).join(" > ");
    return {
      nodeId: node.id,
      frameName: node.name,
      pageName,
      fullPath: fullPath || node.name
    };
  }
  findFrameInfo(nodeId, fileData) {
    const path = [];
    let frameFound = false;
    let pageName = "";
    const findNode = (node, currentPath) => {
      if (node.id === nodeId) {
        frameFound = true;
        return true;
      }
      if (node.children) {
        for (const child of node.children) {
          if (findNode(child, [...currentPath, node])) {
            return true;
          }
        }
      }
      return false;
    };
    if (fileData.document && fileData.document.children) {
      for (const page of fileData.document.children) {
        if (page.type === "CANVAS") {
          pageName = page.name;
          if (findNode(page, [page])) {
            path.unshift(page);
            break;
          }
        }
      }
    }
    if (!frameFound) {
      return null;
    }
    let frameName = "Root";
    const frames = path.filter(
      (node) => node.type === "FRAME" || node.type === "COMPONENT" || node.type === "INSTANCE"
    );
    if (frames.length > 0) {
      frameName = frames[frames.length - 1].name;
    }
    const fullPath = path.slice(1).map((node) => node.name).join(" > ");
    return {
      nodeId,
      frameName,
      pageName,
      fullPath: fullPath || frameName
    };
  }
  cacheFrameInfo(fileKey, nodeId, frameInfo) {
    if (!this.cache[fileKey]) {
      this.cache[fileKey] = {
        fileKey,
        lastUpdated: new Date().toISOString(),
        frameMap: {}
      };
    }
    this.cache[fileKey].frameMap[nodeId] = frameInfo;
  }
  // Public method to clear cache
  clearCache() {
    this.cache = {};
  }
};
var FigmaObsidianSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.syncIntervalId = null;
    this.frameInfoFetcher = null;
  }
  async onload() {
    await this.loadSettings();
    if (this.settings.fetchFrameInfo && this.settings.figmaToken) {
      this.frameInfoFetcher = new FrameInfoFetcher(
        this.settings.figmaToken,
        this.runtimeData.frameInfoCache || {}
      );
    }
    this.addRibbonIcon("sync", "Sync Figma comments", () => {
      this.syncAllFiles(true);
    });
    this.addCommand({
      id: "sync-figma-comments",
      name: "Sync Figma comments",
      callback: () => {
        this.syncAllFiles(true);
      }
    });
    this.addSettingTab(new FigmaObsidianSyncSettingTab(this.app, this));
    if (this.settings.figmaToken && this.settings.figmaFiles.length > 0) {
      this.startAutoSync();
    }
  }
  onunload() {
    this.stopAutoSync();
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS);
    this.runtimeData = Object.assign({}, DEFAULT_RUNTIME_DATA);
    if (loadedData) {
      const { lastSync, frameInfoCache, ...persistentSettings } = loadedData;
      Object.assign(this.settings, persistentSettings);
      if (lastSync)
        this.runtimeData.lastSync = lastSync;
      if (frameInfoCache)
        this.runtimeData.frameInfoCache = frameInfoCache;
    }
    if (this.settings.encryptedToken && !this.settings.figmaToken) {
      this.settings.figmaToken = TokenManager.decrypt(this.settings.encryptedToken);
    }
  }
  async saveSettings() {
    if (this.settings.fetchFrameInfo && this.settings.figmaToken) {
      if (!this.frameInfoFetcher) {
        this.frameInfoFetcher = new FrameInfoFetcher(
          this.settings.figmaToken,
          this.runtimeData.frameInfoCache || {}
        );
      }
    } else {
      this.frameInfoFetcher = null;
    }
    const settingsToSave = { ...this.settings };
    if (this.settings.figmaToken) {
      settingsToSave.encryptedToken = TokenManager.encrypt(this.settings.figmaToken);
      delete settingsToSave.figmaToken;
    }
    delete settingsToSave.lastSync;
    delete settingsToSave.frameInfoCache;
    await this.saveData(settingsToSave);
  }
  startAutoSync() {
    this.stopAutoSync();
    if (this.settings.syncInterval > 0) {
      this.syncIntervalId = this.registerInterval(
        window.setInterval(() => {
          this.syncAllFiles();
        }, this.settings.syncInterval)
      );
    }
  }
  stopAutoSync() {
    if (this.syncIntervalId) {
      window.clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
  }
  async syncAllFiles(clearCache = false) {
    if (!this.settings.figmaToken) {
      new import_obsidian.Notice("Please configure your Figma token in settings");
      return;
    }
    if (this.settings.figmaFiles.length === 0) {
      new import_obsidian.Notice("No Figma files configured for sync");
      return;
    }
    if (clearCache && this.settings.fetchFrameInfo) {
      this.runtimeData.frameInfoCache = {};
      if (this.frameInfoFetcher) {
        this.frameInfoFetcher.clearCache();
      }
      new import_obsidian.Notice("Frame info cache cleared - fetching latest data...");
    }
    new import_obsidian.Notice("Starting Figma sync...");
    const enabledFiles = this.settings.figmaFiles.filter((file) => file.enabled !== false);
    for (const file of enabledFiles) {
      try {
        await this.syncFile(file);
      } catch (error) {
        console.error(`Error syncing file ${file.name}:`, error);
        new import_obsidian.Notice(`Failed to sync ${file.name}: ${error.message}`);
      }
    }
    this.runtimeData.lastSync = new Date().toISOString();
    new import_obsidian.Notice("Figma sync completed");
  }
  async syncFile(file) {
    const comments = await this.fetchComments(file.key);
    await this.saveComments(file, comments);
  }
  async fetchComments(fileKey) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `https://api.figma.com/v1/files/${fileKey}/comments`,
      method: "GET",
      headers: {
        "X-Figma-Token": this.settings.figmaToken
      }
    });
    if (response.status !== 200) {
      throw new Error(`Figma API error: ${response.status}`);
    }
    const data = response.json;
    return data.comments;
  }
  async saveComments(file, comments) {
    const syncFolderPath = (0, import_obsidian.normalizePath)(this.settings.syncFolder);
    await this.ensureFolder(syncFolderPath);
    await this.saveCommentsToSingleFile(syncFolderPath, file, comments);
  }
  async ensureFolder(path) {
    const folder = this.app.vault.getAbstractFileByPath(path);
    if (!folder) {
      await this.app.vault.createFolder(path);
    }
  }
  async saveCommentsToSingleFile(folderPath, file, comments) {
    var _a;
    const filePath = (0, import_obsidian.normalizePath)(`${folderPath}/${file.name}_comments.md`);
    const existingFileWithSameKey = await this.findExistingFileByKey(folderPath, file.key);
    const targetFile = existingFileWithSameKey || filePath;
    let content = `---
title: ${file.name} - Figma Comments
created: ${new Date().toISOString()}
updated: ${new Date().toISOString()}
figma_file_key: ${file.key}
total_comments: ${comments.length}
resolved_comments: ${comments.filter((c) => c.resolved_at).length}
open_comments: ${comments.filter((c) => !c.resolved_at).length}
---

# ${file.name} - Figma Comments

## Summary
- **Total Comments**: ${comments.length}
- **Open Comments**: ${comments.filter((c) => !c.resolved_at).length}
- **Resolved Comments**: ${comments.filter((c) => c.resolved_at).length}
- **Last Sync**: ${new Date().toLocaleString()}
- **File Link**: [Open in Figma](https://www.figma.com/file/${file.key})

## Comments

`;
    const sortedComments = comments.sort(
      (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
    );
    for (const comment of sortedComments) {
      const isResolved = comment.resolved_at !== null;
      const checkbox = isResolved ? "- [x]" : "- [ ]";
      const resolvedInfo = isResolved ? `Resolved: ${new Date(comment.resolved_at).toLocaleString()}` : "Open";
      content += `${checkbox} ${new Date(comment.created_at).toLocaleString()}
  - ${comment.message.replace(/\n/g, "\n    ")}
  - Author: ${comment.user.handle}`;
      if (this.settings.fetchFrameInfo && this.frameInfoFetcher && ((_a = comment.client_meta) == null ? void 0 : _a.node_id)) {
        const coordinates = comment.client_meta.node_offset ? {
          x: comment.client_meta.node_offset.x,
          y: comment.client_meta.node_offset.y
        } : void 0;
        const frameInfo = await this.frameInfoFetcher.getFrameInfo(
          file.key,
          comment.client_meta.node_id,
          coordinates
        );
        if (frameInfo) {
          content += `
  - Frame: ${frameInfo.fullPath}
  - Page: ${frameInfo.pageName}`;
        }
      }
      content += `
  - Status: ${resolvedInfo}

`;
    }
    const existingFile = this.app.vault.getAbstractFileByPath(targetFile);
    if (existingFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(targetFile, content);
    }
  }
  // Find existing file by figma_file_key in frontmatter (handles renamed files)
  async findExistingFileByKey(folderPath, fileKey) {
    var _a;
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder || !(folder instanceof import_obsidian.TFolder))
      return null;
    for (const child of folder.children) {
      if (child instanceof import_obsidian.TFile && child.extension === "md") {
        try {
          const cache = this.app.metadataCache.getFileCache(child);
          if (((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.figma_file_key) === fileKey) {
            return child.path;
          }
        } catch (error) {
          continue;
        }
      }
    }
    return null;
  }
};
var SecurityModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    this.titleEl.textContent = "\u{1F512} Security";
    this.render();
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("p", {
      text: "Your Figma access token is encrypted and stored securely.",
      cls: "setting-item-description"
    });
    const tokenVisible = this.plugin.settings.tokenVisible || false;
    const tokenValue = this.plugin.settings.figmaToken || "";
    const displayValue = tokenVisible ? tokenValue : "\u2022".repeat(Math.min(tokenValue.length, 20));
    new import_obsidian.Setting(contentEl).setName("Figma personal access token").setDesc("Get your token from https://www.figma.com/developers/api#access-tokens").addText((text) => {
      text.setPlaceholder("Enter your token").setValue(displayValue).onChange(async (value) => {
        if (tokenVisible || value !== displayValue) {
          this.plugin.settings.figmaToken = value;
          await this.plugin.saveSettings();
        }
      });
      if (!tokenVisible) {
        text.inputEl.type = "password";
      }
    });
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText(tokenVisible ? "Hide" : "Show").onClick(async () => {
      this.plugin.settings.tokenVisible = !tokenVisible;
      await this.plugin.saveSettings();
      this.render();
    })).addButton((button) => button.setButtonText("Test connection").setCta().onClick(async () => {
      await this.testConnection();
    }));
  }
  async testConnection() {
    if (!this.plugin.settings.figmaToken) {
      new import_obsidian.Notice("Please enter a Figma token first");
      return;
    }
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: "https://api.figma.com/v1/me",
        method: "GET",
        headers: {
          "X-Figma-Token": this.plugin.settings.figmaToken
        }
      });
      if (response.status === 200) {
        const user = response.json;
        new import_obsidian.Notice(`\u2705 Connected successfully as ${user.email}`);
      } else {
        new import_obsidian.Notice(`\u274C Connection failed: ${response.status}`);
      }
    } catch (error) {
      new import_obsidian.Notice(`\u274C Connection failed: ${error.message}`);
    }
  }
};
var FigmaObsidianSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.securityTitle = "\u{1F512} Security Settings";
    this.plugin = plugin;
    this.folderMigration = new FolderMigrationManager(app, plugin);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    await this.syncFileNamesWithActualFiles();
    this.addGeneralSettings(containerEl);
    this.addSecuritySection(containerEl);
    this.addFileManagementSettings(containerEl);
    this.addActionsSection(containerEl);
  }
  addGeneralSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("\u2699\uFE0F General").setHeading();
    new import_obsidian.Setting(containerEl).setName("Sync folder").setDesc('Parent folder for all synced comments. Example: "Figma Comments" \u2192 saves as "Figma Comments/FileName_comments.md"').addText((text) => {
      const oldPath = this.plugin.settings.syncFolder;
      let currentValue = oldPath;
      text.setPlaceholder("Figma Comments").setValue(this.plugin.settings.syncFolder).onChange((value) => {
        currentValue = value;
      });
      text.inputEl.addEventListener("blur", async () => {
        if (oldPath !== currentValue && currentValue.trim() !== "") {
          const migrated = await this.folderMigration.migrateSyncFolder(oldPath, currentValue);
          if (migrated) {
            this.plugin.settings.syncFolder = currentValue;
            await this.plugin.saveSettings();
          } else {
            text.setValue(oldPath);
            currentValue = oldPath;
          }
        } else if (currentValue.trim() === "") {
          text.setValue(oldPath);
          currentValue = oldPath;
          new import_obsidian.Notice("Sync folder cannot be empty");
        }
      });
      return text;
    });
    new import_obsidian.Setting(containerEl).setName("Auto-sync interval (minutes)").setDesc("How often to automatically sync comments (0 to disable)").addText((text) => text.setPlaceholder("5").setValue(String(this.plugin.settings.syncInterval / 6e4)).onChange(async (value) => {
      const minutes = parseInt(value) || 0;
      this.plugin.settings.syncInterval = minutes * 6e4;
      await this.plugin.saveSettings();
      this.plugin.startAutoSync();
    }));
    new import_obsidian.Setting(containerEl).setName("Fetch frame information").setDesc('Retrieve and display which frame/component each comment belongs to (uses additional API calls). Note: Frame information is cached for 24 hours. If Figma frame names are not reflecting after changes, use "Clear Cache" button below or perform manual sync.').addToggle((toggle) => toggle.setValue(this.plugin.settings.fetchFrameInfo || false).onChange(async (value) => {
      this.plugin.settings.fetchFrameInfo = value;
      await this.plugin.saveSettings();
      if (value) {
        new import_obsidian.Notice("Frame information will be fetched on next sync");
      } else {
        new import_obsidian.Notice("Frame information disabled");
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Move empty folders to trash").setDesc("Handle empty folders when changing sync locations. When enabled, folders are moved to trash (following your system settings). When disabled, folders may be permanently deleted depending on your Obsidian configuration.").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = this.plugin.settings.deleteToTrash) != null ? _a : true).onChange(async (value) => {
        this.plugin.settings.deleteToTrash = value;
        await this.plugin.saveSettings();
        if (value) {
          new import_obsidian.Notice("Empty folders will be moved to trash");
        } else {
          new import_obsidian.Notice("Empty folders will be permanently deleted");
        }
      });
    });
  }
  addSecuritySection(containerEl) {
    new import_obsidian.Setting(containerEl).setName("\u{1F512} Security").setHeading();
    new import_obsidian.Setting(containerEl).setName("Figma access token").setDesc("Configure your Figma personal access token securely").addButton((button) => button.setIcon("settings").setTooltip("Open security settings").onClick(() => {
      this.openSecurityModal();
    }));
  }
  openSecurityModal() {
    new SecurityModal(this.app, this.plugin).open();
  }
  addFileManagementSettings(containerEl) {
    new import_obsidian.Setting(containerEl).setName("\u{1F4C1} File management").setHeading();
    containerEl.createEl("p", {
      text: "Manage Figma files to sync comments from. Toggle files on/off to control syncing.",
      cls: "setting-item-description"
    });
    if (this.plugin.settings.figmaFiles.length > 0) {
      this.plugin.settings.figmaFiles.forEach((file, index) => {
        this.addFileEntry(containerEl, file, index);
      });
      containerEl.createEl("div", { cls: "setting-item-heading" });
    }
    this.addNewFileSection(containerEl);
  }
  addFileEntry(containerEl, file, index) {
    const setting = new import_obsidian.Setting(containerEl).setName(`${file.name}`).setDesc(`Key: ${file.key}`);
    setting.addToggle((toggle) => toggle.setValue(file.enabled !== false).onChange(async (value) => {
      this.plugin.settings.figmaFiles[index].enabled = value;
      await this.plugin.saveSettings();
    }));
    setting.addButton((button) => button.setButtonText("Edit").onClick(() => {
      this.editFileDialog(file, index);
    }));
    setting.addButton((button) => button.setButtonText("Remove").setWarning().onClick(async () => {
      this.plugin.settings.figmaFiles.splice(index, 1);
      await this.plugin.saveSettings();
      this.display();
    }));
  }
  addNewFileSection(containerEl) {
    containerEl.createEl("h4", { text: "\u2795 Add new file" });
    let newFileName = "";
    let newFileKey = "";
    const setting = new import_obsidian.Setting(containerEl).setName("Add Figma file").setDesc("Enter a friendly name and the file key from Figma URL");
    setting.addText((text) => text.setPlaceholder("File name").onChange((value) => newFileName = value));
    setting.addText((text) => text.setPlaceholder("File key (e.g., ABC123XYZ)").onChange((value) => newFileKey = value));
    setting.addButton((button) => button.setButtonText("Add").setCta().onClick(async () => {
      if (newFileName && newFileKey) {
        if (newFileKey.length >= 10) {
          const newFile = {
            id: Date.now().toString(),
            name: newFileName,
            key: newFileKey,
            enabled: true
          };
          this.plugin.settings.figmaFiles.push(newFile);
          await this.plugin.saveSettings();
          setting.components.forEach((component) => {
            if (component.inputEl) {
              component.setValue("");
            }
          });
          newFileName = "";
          newFileKey = "";
          this.display();
          new import_obsidian.Notice(`Added "${newFile.name}" to sync list`);
        } else {
          new import_obsidian.Notice("Please enter a valid Figma file key (at least 10 characters)");
        }
      } else {
        new import_obsidian.Notice("Please enter both file name and key");
      }
    }));
  }
  addActionsSection(containerEl) {
    new import_obsidian.Setting(containerEl).setName("\u{1F504} Actions").setHeading();
    if (this.plugin.runtimeData.lastSync) {
      containerEl.createEl("p", {
        text: `Last sync: ${new Date(this.plugin.runtimeData.lastSync).toLocaleString()}`,
        cls: "setting-item-description"
      });
    }
    new import_obsidian.Setting(containerEl).setName("Manual sync").setDesc("Sync all enabled Figma files now").addButton((button) => button.setButtonText("Sync now").setCta().onClick(() => {
      this.plugin.syncAllFiles(true);
    }));
    if (this.plugin.settings.fetchFrameInfo) {
      new import_obsidian.Setting(containerEl).setName("Clear frame info cache").setDesc("Clear cached frame information to fetch the latest data from Figma. Use this if frame names changed in Figma but are not reflecting in synced comments.").addButton((button) => button.setButtonText("Clear cache").onClick(() => {
        this.plugin.runtimeData.frameInfoCache = {};
        if (this.plugin.frameInfoFetcher) {
          this.plugin.frameInfoFetcher.clearCache();
        }
        new import_obsidian.Notice("Frame info cache cleared");
      }));
    }
  }
  editFileDialog(file, index) {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.textContent = "Edit Figma file";
    const content = modal.contentEl;
    let editName = file.name;
    let editKey = file.key;
    new import_obsidian.Setting(content).setName("File name").addText((text) => text.setValue(file.name).onChange((value) => editName = value));
    new import_obsidian.Setting(content).setName("File key").addText((text) => text.setValue(file.key).onChange((value) => editKey = value));
    const buttonContainer = content.createEl("div", { cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => modal.close());
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Save").setCta().onClick(async () => {
      if (editName && editKey) {
        this.plugin.settings.figmaFiles[index] = {
          ...file,
          name: editName,
          key: editKey
        };
        await this.plugin.saveSettings();
        modal.close();
        this.display();
      }
    });
    modal.open();
  }
  // Sync file names in settings with actual file names in vault
  async syncFileNamesWithActualFiles() {
    var _a;
    const syncFolder = this.plugin.settings.syncFolder;
    let hasChanges = false;
    for (let i = 0; i < this.plugin.settings.figmaFiles.length; i++) {
      const file = this.plugin.settings.figmaFiles[i];
      const actualFilePath = await this.plugin.findExistingFileByKey(syncFolder, file.key);
      if (actualFilePath) {
        const actualFileName = ((_a = actualFilePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
        const actualDisplayName = actualFileName.replace(/_comments$/, "");
        if (actualDisplayName !== file.name) {
          this.plugin.settings.figmaFiles[i].name = actualDisplayName;
          hasChanges = true;
        }
      }
    }
    if (hasChanges) {
      await this.plugin.saveSettings();
    }
  }
};
